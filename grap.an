.TH man page 1 "generated by PolyglotMan" UCB
.\"  manual page source format generated by PolyglotMan v3.0.7,
.\"  available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z
.SH Name

.LP
\fBgrap\fR \- Kernighan and Bentley's langauge for typesetting graphs
.SH \fBSynopsis\fR

.LP
\fBgrap\fR [\fB\-d\fR \fIdefines\fR\fB_\fR\fIfile\fR] [\fB\-D\fR] [\fB\-V\fR] [fl u] [\fIfilename\fR \fI...\fR]
.SH \fBDescription\fR

.LP
\fBgrap\fR is an implementation of Kernighan and Bentley's language for typesetting
graphs, as described in ''Grap\-A Language for Typesetting Graphs,
Tutorial and User Manual,'' by Jon L. Bentley and Brian W. Kernighan,
revised May 1991, which is the primary source for information on how to
use \fBgrap\fR. As of this writing, it is available electronically at
http://www.kohala.com/~rstevens/troff/cstr114.ps.
.LP
This version is a black box implementation of \fBgrap\fR, and some inconsistencies
are to be expected. The remainder of this manual page will briefly
outline the \fBgrap\fR language as implemented here.
.LP
\fBgrap\fR is a pic(1) pre\-processor. It takes commands embedded in a troff(1)
source file which are surrounded by \fB.G1\fR and \fB.G2\fR macros, and rewrites them
into pic commands to display the graph. Other lines are copied. Output
is always to the standard output, which is usually reidrected. Input is
from the given \fIfilename\fRs, which are read in the order given. A \fIfilename\fR
of \fB\-\fR is the standard input. If no \fIfilename\fRs are given, input is read
from the standard input.
.LP
Because \fBgrap\fR is a pic preprocessor, and gnu pic will output TeX, it is
possible to use \fBgrap\fR with TeX.
.LP
The \fB\-d\fR option specifies a file of macro definitions to be read at startup,
and defaults to /usr/local/share/grap/grap.defines. The \fB\-D\fR option
inhibits the reading of any initial macros file.
.IP "\fB\-v\fR prints the version on the standard output and exits."
"

"\fB\-u\fR makes labels unaligned by default. "
"
This version of \fBgrap\fR uses new features
of gnu pic to align the left and right labels with the axes, that
is that the left and right labels run at right angles to the text of the
paper. I personally like it better that way and it saves space, but \fB\-u\fR
disables it. This may be useful in porting old .
.LP
All \fBgrap\fR commands are included between \fB.G1\fR and \fB.G2\fR macros, which are consumed
by . The output contains pic between \fB.PS\fR and \fB.PE\fR macros. Any arguments
to the \fB.G1\fR macro in the input are arguments to the \fB.PS\fR macro in the
output, so graphs can be scaled just like pic diagrams.
.LP
The \fBgrap\fR commands are sketched below. Refer to Kernighan and Bentley's
paper for the details.
.LP
\fBCommands\fR
.LP
Commands are separated from one another by newlines or semicolons (;).
.LP
\fBframe\fR [\fIline\fR\fB_\fR\fIdescription\fR] [\fBht\fR \fIheight\fR | \fBwid\fR \fIwidth\fR] [[
(\fBtop\fR|\fBbottom\fR|\fBleft\fR|\fBright\fR) \fIline\fR\fB_\fR\fIdescription\fR] ...]
.LP
\fBframe\fR [\fBht\fR \fIheight\fR | \fBwid\fR \fIwidth\fR] [\fIline\fR\fB_\fR\fIdescription\fR] [[
(\fBtop\fR|\fBbottom\fR|\fBleft\fR|\fBright\fR) \fIline\fR\fB_\fR\fIdescription\fR] ...]
.LP
This describes how the axes for the graph are drawn. A
\fIline\fR\fB_\fR\fIdescription\fR is a pic line description, e.g., dashed 0.5, or
the literal solid. If the first \fIline\fR\fB_\fR\fIdescription\fR is given, the
frame is drawn with that style. The default is solid. The height
and width of the frame can also be specified in inches. The default
line style can be over\-ridden for sides of the frame by specifying
additional parameters to \fBframe\fR.
.LP
\fBcoord\fR [\fIname\fR] [\fBx\fR \fIexpr\fR, \fIexpr\fR] [\fBy\fR \fIexpr\fR, \fIexpr\fR] [\fBlog\fR \fBx\fR | \fBlog\fR \fBy\fR | \fBlog\fR \fBlog\fR]
.LP
The \fBcoord\fR command specifies a new coordinate system or sets limits
on the default system. It defines the largest and smallest values
that can be plotted, and therefore the scale of the data in the
frame. The limits for the x and y coordinate systems can be given
separately. If a \fIname\fR is given, that coordinate system is defined,
if not the default system is modified.
.LP
This command also determines if a scale is plotted logarithmically.
Unlike K&B \fBgrap\fR, this program accepts exactly one of the three logarithm
specifications.
.LP
\fBdraw\fR [\fIline\fR\fB_\fR\fIname\fR] [\fIline\fR\fB_\fR\fIdescription\fR] [\fIplot\fR\fB_\fR\fIstring\fR]
.LP
The \fBdraw\fR command defines the style with which a given line will be
plotted. If \fIline\fR\fB_\fR\fIname\fR is given, the style is associated with that
name, otherwise the default style is set. \fIline\fR\fB_\fR\fIdescription\fR is a
pic line description, and the optional \fIplot\fR\fB_\fR\fIstring\fR is a string to
be centered at each point. The default line description is invis,
and the default plotting string is a centered bullet, so by default
each point is a filled cricle, and they are unconnected. If points
are being connected, each \fBdraw\fR command ends any current line and
begins a new one.
.LP
\fBnew\fR is a synonym for \fBdraw\fR.
.LP
\fBnext\fR [\fIline\fR\fB_\fR\fIname\fR] \fBat\fR [\fIcoordinates\fR\fB_\fR\fIname\fR] \fIexpr\fR, \fIexpr\fR [\fIline\fR\fB_\fR\fIdescription\fR]
.LP
The \fBnext\fR command plots the given point using the line style given
by \fIline\fR\fB_\fR\fIname\fR, or the default if none is given. If \fIline\fR\fB_\fR\fIname\fR is
given, it should have been defined by an earlier \fBdraw\fR command, if
not a new line style with that name is created, initialized the
same way as the default style. The two expressions give the
point's x and y values, relative to the optional coordinate system.
That system should have been defined by an earlier \fBcoord\fR command,
if not, grap will exit. If the optional \fIline\fR\fB_\fR\fIdescription\fR is given,
it overrides the style's default line description. You cannot
over\-ride the plotting string. To use a different plotting string
use the \fBplot\fR command.
.LP
The coordinates may optionally be enclosed in parentheses: (\fIexpr\fR,
\fIexpr\fR)
.LP
\fIquoted\fR\fB_\fR\fIstring\fR [\fIstring\fR\fB_\fR\fImodifiers\fR] [, \fIquoted\fR\fB_\fR\fIstring\fR [ \fIstring\fR\fB_\fR\fImodifiers\fR]]
\&... \fBat\fR [\fIcoordinates\fR\fB_\fR\fIname\fR] \fIexpr\fR, \fIexpr\fR
.LP
\fBplot\fR \fIexpr\fR [\fIformat\fR\fB_\fR\fIstring\fR] \fBat\fR [\fIcoordinates\fR\fB_\fR\fIname\fR] \fIexpr\fR, \fIexpr\fR
.LP
These commands both plot a string at the given point. In the first
case the literal strings are stacked above each other. The string
modifiers include the pic justification modifiers, and absolute and
relative size modifiers. size \fIexpr\fR sets the string size to \fIexpr\fR
points. If \fIexpr\fR is preceded by a + or \-, the size is increased or
decreased by that many points.
.LP
In the second version, the \fIexpr\fR is converted to a string and placed
on the graph. \fIformat\fR\fB_\fR\fIstring\fR is a printf(3) format string. Only
formatting escapes for printing floating point numbers make sense.
.LP
points are specified the same way as for \fBnext\fR commands, with the
same consequences for undefined coordinate systems.
.LP
The second form of this command is completely unnecessary because
the first form can be used with a \fBgrap\fR \fBsprintf\fR experssion (See
\fIExpressions\fR).
.LP
\fBticks\fR (\fBleft\fR|\fBright\fR|\fBtop\fR|\fBbottom\fR) (\fBin\fR|\fBout\fR) [\fIexpr\fR]
.LP
\fBticks\fR (\fBleft\fR|\fBright\fR|\fBtop\fR|\fBbottom\fR) (\fBin\fR|\fBout\fR) [\fIexpr\fR] [\fBup\fR \fIexpr\fR | \fBdown\fR \fIexpr\fR | \fBleft\fR
\fIexpr\fR | \fBright\fR \fIexpr\fR] \fBat\fR [\fIcoord\fR\fB_\fR\fIname\fR] \fIexpr\fR [\fIformat\fR\fB_\fR\fIstring\fR] [[ , \fIexpr\fR[
\fIformat\fR\fB_\fR\fIstring\fR]] ...]
.LP
\fBticks\fR (\fBleft\fR|\fBright\fR|\fBtop\fR|\fBbottom\fR) (\fBin\fR|\fBout\fR) [\fIexpr\fR] [\fBup\fR \fIexpr\fR | \fBdown\fR \fIexpr\fR | \fBleft\fR
\fIexpr\fR | \fBright\fR \fIexpr\fR] \fBfrom\fR [coord_name] \fIstart\fR\fB_\fR\fIexpr\fR \fBto\fR \fIend\fR\fB_\fR\fIexpr\fR [\fBby\fR [+|\-|*|/]
\fIby\fR\fB_\fR\fIexpr\fR] [format_string]
.LP
\fBticks\fR [\fBleft\fR|\fBright\fR|\fBtop\fR|\fBbottom\fR] off
.LP
This command controls the placement of ticks on the frame. By default,
ticks are automatically generated on the left and bottom
sides of the frame.
.LP
The simplest version of this command turns on the automatic tick
generation for a given side. The tick direction is controlled by
specifying \fBin\fR or \fBout\fR, modified by an expression that gives the
length of the ticks in inches.
.LP
The second version of the \fBticks\fR command over\-rides the automatic
placement of the ticks by specifying a list of coordinates at which
to place the ticks. If the ticks are not defined with respect to
the default coordinate system, the \fIcoord\fR\fB_\fR\fIname\fR parameter must be
given. For each tick a printf(3) style format string can be given.
The \fIformat\fR\fB_\fR\fIstring\fR defaults to \*(rq%g". To place ticks with no labels,
specify \fIformat\fR\fB_\fR\fIstring\fR as \*(rq".
.LP
The labels on the ticks may be shifted by specifying a direction
and the distance in inches to offset the label. That is the optional
direction and expression immediately preceding the \fBat\fR.
.LP
The third format of the \fBticks\fR command over\-rides the default tick
generation with a set of ticks ar regular intervals. The syntax is
reminiscent of programming language for loops. Ticks are placed
starting at \fIstart\fR\fB_\fR\fIexpr\fR ending at \fIend\fR\fB_\fR\fIexpr\fR one unit apart. If the
\fBby\fR clause is specified, ticks are \fIby\fR\fB_\fR\fIexpr\fR units apart. If an operator
appears before \fIby\fR\fB_\fR\fIexpr\fR each tick is operated on by that operator
instead of +. For example
.LP
ticks left out from 2 to 32 by *2
.LP
will put ticks at 2, 4, 8, 16, and 32. If \fIformat\fR\fB_\fR\fIstring\fR is specified,
all ticks are formatted using it.
.LP
The parameters preceding the \fBfrom\fR act as described above.
.LP
The \fBat\fR and \fBfor\fR forms of tick command may both be issued on the same
side of a frame. For example:
.LP
ticks left out from 2 to 32 by *2
ticks left in 3, 5, 7
.LP
will put ticks on the left side of the frame pointing out at 2, 4,
8, 16, and 32 and in at 3, 5, and 7.
.LP
The final form of \fBticks\fR turns off ticks on a given side. If no
side is given the ticks for all sides are cancelled.
.LP
\fBtick\fR is a synonym for \fBticks\fR.
.LP
\fBgrid\fR (\fBleft\fR|\fBright\fR|\fBtop\fR|\fBbottom\fR) [ticks off] [\fIline\fR\fB_\fR\fIdescription\fR] [\fBup\fR \fIexpr\fR
\fBdown\fR \fIexpr\fR | \fBleft\fR \fIexpr\fR | \fBright\fR \fIexpr\fR]
.LP
\fBgrid\fR (\fBleft\fR|\fBright\fR|\fBtop\fR|\fBbottom\fR) [ticks off] [\fIline\fR\fB_\fR\fIdescription\fR] [\fBup\fR \fIexpr\fR
\fBdown\fR \fIexpr\fR | \fBleft\fR \fIexpr\fR | \fBright\fR \fIexpr\fR] \fBat\fR [\fIcoord\fR\fB_\fR\fIname\fR] \fIexpr\fR [\fIformat\fR\fB_\fR\fIstring\fR]
[[ , \fIexpr\fR[ \fIformat\fR\fB_\fR\fIstring\fR]] ...]
.LP
\fBgrid\fR (\fBleft\fR|\fBright\fR|\fBtop\fR|\fBbottom\fR) [ticks off] [\fIline\fR\fB_\fR\fIdescription\fR] [\fBup\fR \fIexpr\fR
\fBdown\fR \fIexpr\fR | \fBleft\fR \fIexpr\fR | \fBright\fR \fIexpr\fR] \fBfrom\fR [coord_name] \fIstart\fR\fB_\fR\fIexpr\fR \fBto\fR
\fIend\fR\fB_\fR\fIexpr\fR [\fBby\fR [+|\-|*|/] \fIby\fR\fB_\fR\fIexpr\fR] [format_string]
.LP
The \fBgrid\fR command is similar to the \fBticks\fR command except that \fBgrid\fR
specifies the placement of lines in the frame. The sysntax is similar
to \fBticks\fR as well.
.LP
By specifying ticks off in the command, no ticks are drawn on that
side of the frame. If ticks appear on a side by default, or have
been declared by an earlier \fBticks\fR command, \fBgrid\fR does not cancel
them unless tciks off is specified.
.LP
Instead of a direction for ticks, \fBgrid\fR allows the user to pick a
line descriptionfor the grid lines. The usual pic(1) line descriptions
are allowed.
.LP
Grids are labelled by default. To omit labels, specify the format
string as \*(rq".
.LP
\fBlabel\fR (\fBleft\fR|\fBright\fR|\fBtop\fR|\fBbottom\fR) \fIquoted\fR\fB_\fR\fIstring\fR [\fIstring\fR\fB_\fR\fImodifiers\fR] [,
\fIquoted\fR\fB_\fR\fIstring\fR [ \fIstring\fR\fB_\fR\fImodifiers\fR]] ... [\fBup\fR \fIexpr\fR | \fBdown\fR \fIexpr\fR | \fBleft\fR \fIexpr\fR
| \fBright\fR \fIexpr\fR]
.LP
The \fBlabel\fR command places a label on the given axis. It is possible
to specify several labels, which will be stacked over each other as
in pic(1). The final argument, if present, specifies how many
inches the label is shifted from the axis.
.LP
By default the labels on the left and right labels run parallel to
the frame. You can cancel this by specifying unaligned as a
\fIstring\fR\fB_\fR\fImodifier\fR.
.LP
\fBcircle\fR \fBat\fR [\fIcoordinate\fR\fB_\fR\fIname\fR] \fIexpr\fR, \fIexpr\fR [\fBradius\fR \fIexpr\fR] [linedesc]
.LP
This draws an circle at the point indicated. By default, the circle
is small, 0.025 inches. This can be over\-ridden by specifying
a radius. The coordinates of the point are relative to the named
coordinate system, or the default system if none is specified.
.LP
This command has been extended to take a line description, e.g.
dotted. It also accepts the filling extensions described below in
the \fBbar\fR command.
.LP
\fBline\fR [\fIline\fR\fB_\fR\fIdescription\fR] \fBfrom\fR [\fIcoordinate\fR\fB_\fR\fIname\fR] \fIexpr\fR, \fIexpr\fR \fBto\fR
[\fIcoordinate\fR\fB_\fR\fIname\fR] \fIexpr\fR, \fIexpr\fR [\fIline\fR\fB_\fR\fIdescription\fR]
.LP
\fBarrow\fR [\fIline\fR\fB_\fR\fIdescription\fR] \fBfrom\fR [\fIcoordinate\fR\fB_\fR\fIname\fR] \fIexpr\fR, \fIexpr\fR \fBto\fR
[\fIcoordinate\fR\fB_\fR\fIname\fR] \fIexpr\fR, \fIexpr\fR [\fIline\fR\fB_\fR\fIdescription\fR]
.LP
This draws a line or arrow from the first point to the second using
the given style. The default line style is solid. The
\fIline\fR\fB_\fR\fIdescription\fR can be given either before the \fBfrom\fR or after the
\fBto\fR clause. If both are given the second is used. It is possible
to specify one point in one coordinate system and one in another,
note that if both points are in a named coordinate system, both
points must have \fIcoordinate\fR\fB_\fR\fIname\fR given.
.LP
\fBcopy\fR \*(rq\fIfilename\fR"
.LP
\fBcopy\fR ["\fIfilename\fR"] [\fBuntil\fR \*(rq\fIstring\fR"] \fBthru\fR \fImacro\fR
.LP
The \fBcopy\fR command imports data from another file into the current
graph. The first form is a simple file inclusion; the included
file is simply read into the input stream and can contain arbitrary
\fBgrap\fR commands.
.LP
The second form takes lines from the file, splits them into words
delimited by one or more spaces, and calls the given macro with
those words as parameters. The macro may either be defined here,
or be a macro defined earlier. See \fIMacros\fR for more information on
macros.
.LP
The \fIfilename\fR may be omitted from the second form if the \fBuntil\fR
clause is present. If so the current file is treated as the input
file until \fIstring\fR is encountered at the beginning of the line.
.LP
\fBcopy\fR is one of the workhorses of \fBgrap\fR. Check out the paper and
\fI/usr/local/share/grap/examples\fR for more details.
\fBprint\fR (\fIexpr|string\fR)
.LP
Prints its argument to the standard error.
.LP
\fBsh\fR \fIblock\fR
.LP
This passes \fIblock\fR to sh(1). Unlike K&B \fBgrap\fR no macro or variable
expansion is done. I believe that this is also true for gnu pic
version 1.10. See the \fIMacros\fR section for information on defining
blocks.
.LP
\fBpic\fR \fIpic\fR\fB_\fR\fIstatement\fR
.LP
This issues the given pic statements in the enclosing \fB.PS\fR and \fB.PE\fR
macros before the pic commands to draw the graph.
.LP
Statements that begin with a period are considered to be
troff(statements) and are output in the enclosing \fB.PS\fR and \fB.PE\fR
macros before the pic commands to draw the graph.
.LP
\fBgraph\fR \fIName\fR \fIpic\fR\fB_\fR\fIcommands\fR
.LP
This command is used to position graphs with respect to each other.
The current graph is given the pic name \fIName\fR ( pic names begin with
capital letters). Any pic commands following the graph are used to
position the next graph. The frame of the graph is available for
use with pic name Frame. The following places a second graph below
the first:
.LP
graph Linear
.br
[ graph description ]
.br
graph Exponential with .Frame.n at \\
Linear.Frame.s \- (0, .05)
[ graph description ]
.LP
\fIname\fR \fI=\fR \fIexpr\fR
.LP
This assigns \fIexpr\fR to the variable \fIname\fR. \fBgrap\fR has only numeric (double)
variables. Unlike K&B \fBgrap\fR, assignment is not part of an expression,
so
.LP
a = b = c = 3
.LP
is illegal.
.LP
Assignment creates a variable if it does not exist. Variables presist
across graphs.
.LP
\fBbar\fR (\fBup\fR|\fBright\fR) [\fIcoordinates\fR\fB_\fR\fIname\fR] \fIoffset\fR \fBht\fR \fIheight\fR [\fBwid\fR \fIwidth\fR] [\fBbase\fR
\fIbase\fR\fB_\fR\fIoffset\fR] [\fIline\fR\fB_\fR\fIdescription\fR]
.LP
\fBbar\fR [\fIcoordinates\fR\fB_\fR\fIname\fR] \fIexpr\fR, \fIexpr\fR, [\fIcoordinates\fR\fB_\fR\fIname\fR] \fIexpr\fR, \fIexpr\fR,
[\fIline\fR\fB_\fR\fIdescription\fR]
.LP
The \fBbar\fR command facilitates drawing bar graphs. The first form of
the command describes the bar somewhat generally and has \fBgrap\fR place
it. The bar may extend up or to the right, is centered on \fIoffset\fR
and extends up or right \fIheight\fR units (in the given coordinate system).
For example
.LP
bar up 3 ht 2
.LP
draws a 2 unit high bar sitting on the x axis, centered on x=3. By
default bars are 1 unit wide, but this can be changed with the \fBwid\fR
keyword. By default bars sit on the base axis, i.e., bars directed
up will extend from y=0. That may be overriden by the \fBbase\fR keyword.
(The bar described above has corners (2.5, 0) and (3.5, 2).)
.LP
The line description has been extended to include a \fBfill\fR \fIexpr\fR keyword
that specifies the shading inside the bar. Bars may be drawn
in any line style.
.LP
The second form of the command draws a box with the two points as
corners. This can be used to draw boxes highlighting certain data
as well as bar graphs. Note that filled bars will cover data drawn
under them.
.LP
\fBControl\fR \fBFlow\fR
.LP
\fBif\fR \fIexpr\fR \fBthen\fR \fIblock\fR [\fBelse\fR \fIblock\fR]
.LP
The \fBif\fR statement provides simple conditional execution. If \fIexpr\fR is
non\-zero, the \fIblock\fR after the \fBthen\fR statement is executed. If not
the \fIblock\fR after the \fBelse\fR is executed, if present. See \fIMacros\fR for
the definition of blocks. Early versions of my grap treated the
blocks as macros defined and expanded in place. This led to unnecessary
confusion because explicit separators were sometimes called
for. Now, \fBgrap\fR inserts a separator (;) after the last character in
\fIblock\fR, so constructs like
.LP
if (x == 3) { y = y + 1 }
.br
x = x + 1
.LP
behave as expected. A separator is also appended to the end of a
\fBfor\fR block.
.LP
\fBfor\fR \fIname\fR \fBfrom\fR \fIfrom\fR\fB_\fR\fIexpr\fR \fBto\fR [\fBby\fR [+|\-|*|/] \fIby\fR\fB_\fR\fIexpr\fR] \fIblock\fR
.LP
This command executes \fIblock\fR iteratively. The variable \fIname\fR is set
to \fIfrom\fR\fB_\fR\fIexpr\fR and incremented by \fIby\fR\fB_\fR\fIexpr\fR until it exceeds \fIto\fR\fB_\fR\fIexpr\fR.
The iteration has the semantics defined in the \fBticks\fR command. The
definition of \fIblock\fR is discussed in \fIMarcos\fR. See also the note about
implicit separators in the description of the \fBif\fR command.
.LP
An \fB=\fR can be used in place of \fBfrom\fR.
.LP
\fBExpressions\fR
.LP
\fBgrap\fR supports a most standard arithmatic operators: + \- / * ^. The carat
(^) is exponentiation. It also supports the C logical operators ==, !=,
&&, || and unary !. == and != are overloaded for the comparison of quoted
strings. Parentheses are used for grouping.
.LP
Assignment is not allowed in an expression.
.LP
\fBgrap\fR supports the following functions that take one argument: \fBlog\fR, \fBexp\fR,
\fBint\fR, \fBsin\fR, \fBcos\fR The logarithms are base 10 and the trigonometric functions
are in radians. If \fBrand\fR is given an argument, it seeds the random number
generator with that value. Called with no arguments, it returns a random
number uniformly distributed on [0,1). The following two argument functions
are supported: \fBatan2\fR, \fBmin\fR, \fBmax\fR. \fBatan2\fR works just like atan2(3).
.LP
Other than string comparison, no expressions can use strings. One string
valued function exists: \fBsprintf\fR (\fIformat\fR, [\fIexpr\fR [\fI,\fR \fIexpr\fR]] ). It operates
like sprintf(3), except returning the value. It can be used anywhere a
quoted string is used.
.LP
\fBMacros\fR
.br
\fBgrap\fR has a simple but powerful macro facility. Macros are defined using
the \fBdefine\fR command :
.LP
\fBdefine\fR \fIname\fR \fIblock\fR
.LP
Every occurrance of \fIname\fR in the program text is replaced by the
contents of \fIblock\fR. \fIblock\fR is defined by a series of statements in
nested { }'s, or a series of statements surrounded by the same letter.
An example of the latter is
.LP
define foo X coord x 1,3 X
Each time foo appears in the text, it will be replaced by coord x
1,3. Macros are literal, and can contain newlines. If a macro does
not span multiple lines, it should end in a semicolon to avoid
parsing errors.
.LP
Macros can take parameters, too. If a macro call is followed by a
parenthesized, comma\-separated list the values starting with $1
will be replaced in the macro with the elements of the list. A $
not followed by a digit is left unchanged. This parsing is very
rudimentary, no nesting or parentheses or escaping of commas is allowed.
Also, there is no way to say argument 1 followed by a digit
(${1}0 in sh(1)).
.LP
The following will draw a line with slope 1.
.LP
define foo { next at $1, $2 }
for i from 1 to 5 { foo(i,i) }
Macros persist across graphs. The file
\fI/usr/local/share/grap/grap.defines\fR contains simple macros for plotting
common characters.
.LP
See the file \fI/usr/local/share/grap/examples\fR for more examples of
macros.
.LP
\fBNumber\fR \fBLists\fR
.LP
A whitespace\-separated list of numbers is treated specially. The list is
taken to be points to be plotted using the default line style on the default
coordinate system. If more than two numbers are given, the extra
numbers are taken to be additional y values to plot at the first x value.
.IP "1 2 3"
"

4 5 6
.LP
Will plot points using the default line style at (1,2), (1,3),(4,5) and
(4,6). A simple way to plot a set of numbers in a file named \fI./data\fR is:
.LP
copy \*(rq./data"
.SH \fBFiles\fR

.LP
\fI/usr/local/share/grap/grap.defines\fR
.SH \fBSee\fR \fBAlso\fR

.LP
atan2(3), groff(1), pic(1), printf(3), sh(1), sprintf(3), troff(1)
.SH \fBAuthor\fR

.LP
This implementation was done by Ted Faber <faber@lunabase.org>. \fBgrap\fR was
designed and specified by Brian Kernighan and Jon Bentley.
.SH \fBBugs\fR

.LP
There are several small incompatibilities with K&R \fBgrap\fR. They include assignments
not being treated as expressions, the \fBsh\fR command not expanding
variables and macros, and a more strict adherence to parameter order in
the internal commands.

