.\"-*-nroff-*-
.\" This file is (c) 1998 Ted Faber (faber@lunabase.org) see COPYRIGHT
.\" for the full copyright and limitations of liabilities.
.Dd August 19, 1998
.Os FreeBSD 2.2.7
.Dt GRAP 1
.Sh NAME
.Nm grap 
.Nd Kernighan and Bentley's langauge for typesetting graphs
.Sh SYNOPSIS
.Nm
.Op Fl d Ar defines_file
.Op Fl D
.Op Fl V
.Op fl u
.Op Ar filename ...
.Sh DESCRIPTION
.Nm
is an implementation of Kernighan and Bentley's language for
typesetting graphs, as described in ``Grap-A Language for Typesetting
Graphs, Tutorial and User Manual,'' by Jon L. Bentley and Brian W.
Kernighan, revised May 1991, which is the primary source for
information on how to use
.Nm grap .
As of this writing, it is available electronically at 
.Li http://www.kohala.com/~rstevens/troff/cstr114.ps .
.Pp
This version is a black box implementation of 
.Nm grap ,
and some inconsistencies are to be expected.  The remainder of this
manual page will briefly outline the
.Nm
language as implemented here.
.Pp
.Nm
is a 
.Xr pic 1
pre-processor.  It takes commands embedded in a 
.Xr troff 1
source file which are surrounded by 
.Ic .G1
and
.Ic .G2
macros, and rewrites them into pic commands to display the graph.
Other lines are copied.  Output is always to the standard output,
which is usually reidrected.  Input is from the given
.Ar filename Ns No s ,
which are read in the order given.  A 
.Ar filename 
of 
.Fl 
is the standard input.
If no 
.Ar filename Ns No s
are given, input is read from the standard input.
.Pp
Because
.Nm
is a 
.Xr pic 
preprocessor, and gnu 
.Xr pic 
will output TeX, it is possible to use
.Nm
with TeX.
.Pp
The 
.Fl d
option specifies a file of macro definitions to be read at startup,
and defaults to DEFINES.
The
.Fl D
option inhibits the reading of any initial macros file.
.Pp
.Fl v
prints the version on the standard output and exits.
.Pp
.Fl u
makes labels unaligned by default.  This version of 
.Nm
uses new features of gnu pic to align the left and right labels with
the axes, that is that the left and right labels run at right angles
to the text of the paper.  I personally like it better that way and it
saves space, but 
.Fl u
disables it.  This may be useful in porting old 
.Nm grap .
.Pp
All
.Nm
commands are included between 
.Ic .G1
and
.Ic .G2
macros, which are consumed by 
.Nm grap .
The output contains pic between
.Ic .PS
and
.Ic .PE
macros.  Any arguments to the
.Ic .G1
macro in the input are arguments to the
.Ic .PS
macro in the output, so graphs can be scaled just like pic diagrams.
.Pp
The 
.Nm
commands are sketched below.  Refer to Kernighan and Bentley's paper
for the details.
.Ss Commands
.Pp
Commands are separated from one another by newlines or semicolons (;).
.Pp
.Ic frame 
.Op Ar line_description 
.Oo
.Bk -word
.Cm ht Ar height No \(or Cm wid Ar width
.Ek
.Oc
.Oo
.Bk -word
.Oo
.Sm off
.Cm ( top No \(or Cm bottom No \(or 
.Cm left No \(or 
.Sm on
.Cm right )
.Ar line_description 
.Ek
.Oc
\&...
.Oc
.sp
.Ic frame 
.Oo
.Bk -word
.Cm ht Ar height No \(or Cm wid Ar width
.Ek
.Oc
.Op Ar line_description 
.Oo
.Bk -word
.Oo
.Sm off
.Cm ( top No \(or Cm bottom No \(or 
.Cm left No \(or 
.Sm on
.Cm right )
.Ar line_description 
.Ek
.Oc
\&...
.Oc
.Bd -filled -offset indent
This describes how the axes for the graph are drawn. A
.Ar line_description 
is a pic line description, e.g., dashed 0.5, or the literal
.Li solid .
If the first 
.Ar line_description 
is given, the frame is drawn with that style.  The default is 
.Li solid .
The height and width of the frame can also be specified in inches.
The default line style can be over-ridden for sides of the frame by
specifying additional parameters to
.Ic frame .
.Ed 
.Pp
.Ic coord
.Op Ar name
.Op Cm x Ar expr , expr
.Op Cm y Ar expr , expr
.Oo
.Cm log x No \(or
.Cm log y No \(or
.Cm log log 
.Oc
.Bd -filled -offset indent
The
.Ic coord
command specifies a new coordinate system or sets limits on the
default system.  It defines the largest and smallest values that can
be plotted, and therefore the scale of the data in the frame.  The
limits for the x and y coordinate systems can be given separately.  If
a 
.Ar name
is given, that coordinate system is defined, if not the default system
is modified.
.Pp
This command also determines if a scale is plotted logarithmically.
Unlike K&B 
.Nm grap ,
this program accepts exactly one of the three logarithm
specifications.
.Ed
.Pp
.Ic draw
.Op Ar line_name
.Op Ar line_description
.Op Ar plot_string 
.Bd -filled -offset indent
The
.Ic draw
command defines the style with which a given line will be plotted.  If
.Ar line_name 
is given, the style is associated with that name, otherwise the
default style is set.  
.Ar line_description
is a pic line description, and the optional
.Ar plot_string
is a string to be centered at each point.  The default line
description is
.Li invis ,
and the default plotting string is a centered bullet, so by default
each point is a filled cricle, and they are unconnected.
If points are being connected, each
.Ic draw
command ends any current line and begins a new one.
.Pp
.Ic new
is a synonym for 
.Ic draw .
.Ed 
.Pp
.Ic next
.Op Ar line_name
.Cm at
.Op Ar coordinates_name 
.Ar expr ,  expr
.Op Ar line_description 
.Bd -filled -offset indent
The 
.Ic next
command plots the given point using the line style given by
.Ar line_name ,
or the default if none is given.  If
.Ar line_name
is given, it should have been defined by an earlier
.Ic draw
command, if not a new line style with that name is created,
initialized the same way as the default style.  The two expressions
give the point's x and y values, relative to the optional coordinate
system.  That system should have been defined by an earlier
.Ic coord
command, if not, grap will exit.  If the optional
.Ar line_description
is given, it overrides the style's default line description.  You
cannot over-ride the plotting string.  To use a different plotting
string use the 
.Ic plot
command.
.Pp
The coordinates may optionally be enclosed in parentheses: 
.Ar ( expr ,  expr )
.Ed
.Pp
.Ar quoted_string 
.Op Ar string_modifiers 
.Oo
.No , Ar quoted_string 
.Oo 
.Ar string_modifiers
.Oc
.Oc
\&...
.Cm at
.Op Ar coordinates_name 
.Ar expr , expr
.Pp
.Ic plot 
.Ar expr
.Op Ar format_string 
.Cm at
.Op Ar coordinates_name 
.Ar expr , expr
.Bd -filled -offset indent
These commands both plot a string at the given point.  In the first
case the literal strings are stacked above each other.  The string
modifiers include the
.Xr pic 
justification modifiers, and absolute and
relative
.Li size
modifiers.
.IP
.Li size
.Ar expr
sets the string size to 
.Ar expr
points.  If 
.Ar expr
is preceded by a + or -, the size is increased or decreased by that
many points.
.Pp
In the second version, the 
.Ar expr
is converted to a string and placed on the graph.  
.Ar format_string 
is a 
.Xr printf 3
format string.  Only formatting escapes for printing
floating point numbers make sense.
.Pp
points are specified the same way as for 
.Ic next
commands, with the same consequences for undefined coordinate systems.
.Pp
The second form of this command is completely unnecessary because the
first form can be used with a 
.Nm
.Ic sprintf
experssion (See
.Sx Expressions ) .
.Ed
.Pp
.Ic ticks
.Sm off
.No Xo ( Cm left No \(or Cm right 
.No \(or Cm top No \(or Cm bottom )
.Xc
.Sm on
.No Xo ( Cm in Ns No \(or 
.Ns Cm out )
.Xc
.Op Ar expr
.Pp
.Ic ticks 
.Sm off
.No Xo ( Cm left No \(or Cm right 
.No \(or Cm top No \(or Cm bottom )
.Xc
.Sm on
.No Xo ( Cm in Ns No \(or 
.Ns Cm out )
.Xc
.Op Ar expr
.Oo
.Cm up Ar expr No \(or
.Cm down Ar expr No \(or
.Cm left Ar expr No \(or
.Cm right Ar expr
.Oc
.Cm at
.Op Ar coord_name
.Ar expr
.Op Ar format_string
.Oo
.Oo
.No , Ar expr
.Oo
.Ar format_string
.Oc
.Oc
.No ...
.Oc
.Pp
.Ic ticks 
.Sm off
.No Xo ( Cm left No \(or Cm right 
.No \(or Cm top No \(or Cm bottom )
.Xc
.Sm on
.No Xo ( Cm in Ns No \(or 
.Ns Cm out )
.Xc
.Op Ar expr
.Oo
.No Cm up Ar expr No \(or
.Cm down Ar expr No \(or
.Cm left Ar expr No \(or
.Cm right Ar expr
.Oc
.Cm from
.Op coord_name
.Ar start_expr
.Cm to
.Ar end_expr
.Oo 
.Cm by 
.Sm off
.Oo
.No + \(or - \(or * \(or /
.Sm on
.Oc
.Ar by_expr
.Oc
.Op format_string
.Pp
.Ic ticks
.Sm off
.Oo
.Cm left Xo No \(or Cm right 
.No \(or Cm top No \(or Cm bottom
.Oc
.Xc
.Sm on
.Li off
.Bd -filled -offset indent
This command controls the placement of ticks on the frame.  By
default, ticks are automatically generated on the left and bottom
sides of the frame.
.Pp
The simplest version of this command turns on the automatic tick
generation for a given side.  The tick direction is controlled by
specifying
.Cm in
or
.Cm out ,
modified by an expression that gives the length of the ticks in
inches.
.Pp
The second version of the
.Ic ticks
command over-rides the automatic placement of the ticks by specifying
a list of coordinates at which to place the ticks.  If the ticks are
not defined with respect to the default coordinate system, the
.Ar coord_name
parameter must be given.  For each tick a 
.Xr printf 3
style format string can be given.  The
.Ar format_string
defaults to
.Qq %g .  
To place ticks with no labels, specify 
.Ar format_string 
as
.Qq \& .
.Pp
The labels on the ticks may be shifted by specifying a direction and
the distance in inches to offset the label.  That is the optional
direction and expression immediately preceding the 
.Cm at .
.Pp
The third format of the 
.Ic ticks
command over-rides the default tick generation with a set of ticks ar
regular intervals.  The syntax is reminiscent of programming
language for loops.  Ticks are placed starting at
.Ar start_expr
ending at
.Ar end_expr
one unit apart.  If the
.Cm by
clause is specified, ticks are
.Ar by_expr
units apart.  If an operator appears before
.Ar by_expr
each tick is operated on by that operator instead of +.  For example
.Bd -literal -offset indent-two
ticks left out from 2 to 32 by *2
.Ed
.Pp
will put ticks at 2, 4, 8, 16, and 32.  If
.Ar format_string
is specified, all ticks are formatted using it.
.Pp
The parameters preceding the
.Cm from
act as described above.
.Pp
The 
.Cm at
and 
.Cm for
forms of tick command may both be issued on the same
side of a frame.  For example:
.Bd -literal -offset indent-two
ticks left out from 2 to 32 by *2
ticks left in 3, 5, 7
.Ed
.Pp
will put ticks on the left side of the frame pointing out at 2, 4, 8,
16, and 32 and in at 3, 5, and 7.
.Pp
The final form of 
.Ic ticks
turns off ticks on a given side.  If no side is given the ticks for
all sides are cancelled.
.Pp
.Ic tick
is a synonym for 
.Ic ticks .
.Ed
.Pp
.Ic grid
.Sm off
.No Xo ( Cm left No \(or Cm right 
.No \(or Cm top No \(or Cm bottom )
.Xc
.Sm on
.Op Li ticks off
.Op Ar line_description
.Oo
.Cm up Ar expr No \(or
.Cm down Ar expr No \(or
.Cm left Ar expr No \(or
.Cm right Ar expr
.Oc
.Pp
.Ic grid
.Sm off
.No Xo ( Cm left No \(or Cm right 
.No \(or Cm top No \(or Cm bottom )
.Xc
.Sm on
.Op Li ticks off
.Op Ar line_description
.Oo
.Cm up Ar expr No \(or
.Cm down Ar expr No \(or
.Cm left Ar expr No \(or
.Cm right Ar expr
.Oc
.Cm at
.Op Ar coord_name
.Ar expr
.Op Ar format_string
.Oo
.Oo
.No , Ar expr
.Oo
.Ar format_string
.Oc
.Oc
.No ...
.Oc
.Pp
.Ic grid 
.Sm off
.No Xo ( Cm left No \(or Cm right 
.No \(or Cm top No \(or Cm bottom )
.Xc
.Sm on
.Op Li ticks off
.Op Ar line_description
.Oo
.No Cm up Ar expr No \(or
.Cm down Ar expr No \(or
.Cm left Ar expr No \(or
.Cm right Ar expr
.Oc
.Cm from
.Op coord_name
.Ar start_expr
.Cm to
.Ar end_expr
.Oo 
.Cm by 
.Sm off
.Oo
.No + \(or - \(or * \(or /
.Sm on
.Oc
.Ar by_expr
.Oc
.Op format_string
.Bd -filled -offset indent
The
.Ic grid
command is similar to the 
.Ic ticks
command except that 
.Ic grid
specifies the placement of lines in the frame.  The sysntax is similar
to 
.Ic ticks
as well.  
.Pp
By specifying 
.Li ticks off
in the command, no ticks are drawn on that side of the frame.  If
ticks appear on a side by default, or have been declared by an earlier
.Ic ticks
command, 
.Ic grid
does not cancel them unless 
.Li tciks off
is specified.
.Pp
Instead of a direction for ticks, 
.Ic grid
allows the user to pick a line descriptionfor the grid lines.  The
usual
.Xr pic 1
line descriptions are allowed.
.Pp
Grids are labelled by default.  To omit labels, specify the format
string as 
.Qq \& .
.Ed
.Pp
.Ic label
.Sm off
.No Xo ( Cm left No \(or Cm right 
.No \(or Cm top No \(or Cm bottom )
.Xc
.Sm on
.Ar quoted_string 
.Op Ar string_modifiers 
.Oo
.No , Ar quoted_string 
.Oo 
.Ar string_modifiers
.Oc
.Oc
\&...
.Oo
.No Cm up Ar expr No \(or
.Cm down Ar expr No \(or
.Cm left Ar expr No \(or
.Cm right Ar expr
.Oc
.Bd -filled -offset indent
The 
.Ic label
command places a label on the given axis.  It is possible to specify
several labels, which will be stacked over each other as in 
.Xr pic 1 .
The final argument, if present, specifies how many inches the label is
shifted from the axis.
.Pp
By default the labels on the left and right labels run parallel to the
frame.  You can cancel this by specifying 
.Li unaligned 
as a 
.Ar string_modifier .
.Ed
.Pp
.Ic circle
.Cm at
.Op Ar coordinate_name
.Ar expr , expr
.Op Cm radius Ar expr
.Op linedesc
.Bd -filled -offset indent
This draws an circle at the point indicated.  By default, the
circle is small, 0.025 inches.  This can be over-ridden by specifying
a radius.  The coordinates of the point are relative to the named
coordinate system, or the default system if none is specified.
.Pp
This command has been extended to take a line description,
e.g. dotted.  It also accepts the filling extensions described below
in the 
.Ic bar
command.
.Ed
.Pp
.Ic line 
.Op Ar line_description
.Cm from
.Op Ar coordinate_name
.Ar expr , expr
.Cm to 
.Op Ar coordinate_name
.Ar expr , expr
.Op Ar line_description
.Pp
.Ic arrow
.Op Ar line_description
.Cm from
.Op Ar coordinate_name
.Ar expr , expr
.Cm to 
.Op Ar coordinate_name
.Ar expr , expr
.Op Ar line_description
.Bd -filled -offset indent
This draws a line or arrow from the first point to the second using
the given style.  The default line style is 
.Li solid .
The 
.Ar line_description
can be given either before the
.Cm from
or after the 
.Cm to
clause.  If both are given the second is used.  It is possible to
specify one point in one coordinate system and one in another, note
that if both points are in a named coordinate system, both points must
have
.Ar coordinate_name
given.
.Ed
.Pp
.Ic copy 
.Qo 
.Ar filename 
.Qc
.Pp
.Ic copy
.Op Qq Ar filename
.Op Cm until Qq Ar string
.Cm thru Ar macro
.Bd -filled -offset indent
The
.Ic copy
command imports data from another file into the current graph.  The
first form is a simple file inclusion; the included file is simply
read into the input stream and can contain arbitrary
.Nm
commands.
.Pp
The second form takes lines from the file, splits them into words
delimited by one or more spaces, and calls the given macro with those
words as parameters.  The macro may either be defined here, or be a
macro defined earlier.  See
.Sx Macros
for more information on macros.
.Pp
The
.Ar filename
may be omitted from the second form if the 
.Cm until
clause is present.  If so the current file is treated as the input
file until
.Ar string
is encountered at the beginning of the line.
.Pp
.Ic copy
is one of the workhorses of 
.Nm grap .
Check out the paper and 
.Pa EXAMPLES
for more details.
.Ed
.Ic print 
.Sm off 
.Ar ( expr \(or string )
.Sm on
.Bd -filled -offset indent
Prints its argument to the standard error.
.Ed
.Pp
.Ic sh Ar block
.Bd -filled -offset indent
This passes 
.Ar block
to 
.Xr sh 1 .
Unlike K&B 
.Nm
no macro or variable expansion is done.  I believe that this is also
true for gnu pic version 1.10.  See the 
.Sx Macros
section for information on defining blocks.
.Ed
.Pp
.Ic pic Ar pic_statement
.Bd -filled -offset indent
This issues the given 
.Xr pic
statements  in the enclosing
.Ic .PS
and 
.Ic .PE
macros before the 
.Xr pic
commands to draw the graph.
.Pp
Statements that begin with a period are considered to be 
.Xr troff statements
and are output in the enclosing
.Ic .PS
and 
.Ic .PE
macros before the 
.Xr pic
commands to draw the graph.
.Ed
.Pp
.Ic graph Ar Name pic_commands
.Bd -filled -offset indent
This command is used to position graphs with respect to each other.
The current graph is given the
.Xr pic
name
.Ar Name
(
.Xr pic
names begin with capital letters).  Any 
.Xr pic
commands following the graph are used to position the next graph.  The
frame of the graph is available for use with
.Xr pic
name
.Li Frame.  
The following places a second graph below the first:
.Bd -literal -offset indent-two
graph Linear
[ graph description ]
graph Exponential with .Frame.n at \\
	Linear.Frame.s - (0, .05)
[ graph description ]
.Ed
.Ed
.Pp
.Ar name = expr
.Bd -filled -offset indent
This assigns 
.Ar expr 
to the variable
.Ar name .
.Nm
has only numeric (double) variables.
.Pp
Assignment creates a variable if it does not exist.  Variables persist
across graphs.
.Ed
.Pp
.Ic bar 
.Sm off
.No ( Cm up No \(or Cm right )
.Sm on
.Op Ar coordinates_name
.Ar offset
.Cm ht
.Ar height
.Op Cm wid Ar width
.Op Cm base Ar base_offset
.Op Ar line_description
.Pp
.Ic bar
.Op Ar coordinates_name
.Ar expr , expr ,
.Op Ar coordinates_name
.Ar expr , expr ,
.Op Ar line_description
.Bd -filled -offset indent
The 
.Ic bar
command facilitates drawing bar graphs.  The first form of the
command describes the bar somewhat generally and has 
.Nm
place it.
The bar may extend up or to the right, is centered on 
.Ar offset
and extends up or right 
.Ar height 
units (in the given coordinate system).  For example
.Bd -literal -offset indent-two
bar up 3 ht 2
.Ed
.Pp
draws a 2 unit high bar sitting on the x axis, centered on x=3.  By
default bars are 1 unit wide, but this can be changed with the 
.Ic wid
keyword.  By default bars sit on the base axis, i.e., bars directed up
will extend from y=0.  That may be overriden by the 
.Ic base
keyword.  (The bar described above has corners (2.5, 0) and (3.5, 2).)
.Pp
The line description has been extended to include a 
.Ic fill Ar expr
keyword that specifies the shading inside the bar.  Bars may be drawn
in any line style.
.Pp
The second form of the command draws a box with the two points as
corners.  This can be used to draw boxes highlighting certain data as
well as bar graphs.  Note that filled bars will cover data drawn under
them.
.Ed
.Ss Control Flow
.Pp
.Ic if Ar expr Ic then Ar block
.Op Ic else Ar block
.Bd -filled -offset indent
The
.Ic if
statement provides simple conditional execution.  If
.Ar expr 
is non-zero, the 
.Ar block 
after the 
.Ic then
statement is executed.  If not the 
.Ar block 
after the
.Ic else
is executed, if present.  See
.Sx Macros
for the definition of blocks.  Early versions of my grap treated the
blocks as macros defined and expanded in place.  This led to
unnecessary confusion because explicit separators were sometimes
called for.  Now,
.Nm
inserts a separator (;) after the last character in 
.Ar block ,
so constructs like 
.Bd -literal
if (x == 3) { y = y + 1 }
x = x + 1

.Ed
behave as expected.  A separator is also appended to the end of a
.Ic for
block.
.Ed
.Pp
.Ic for Ar name Ic from Ar from_expr Ic to Ar to_expr
.Oo
.Ic by 
.Op No +\(or-\(or*\(or/
.Ar by_expr
.Oc
.Ar block
.Bd -filled -offset indent
This command executes 
.Ar block
iteratively.  The variable
.Ar name
is set to 
.Ar from_expr
and incremented by
.Ar by_expr 
until it exceeds 
.Ar to_expr .
The iteration has the semantics defined in the 
.Ic ticks 
command.  The definition of
.Ar block
is discussed in 
.Sx Marcos .
See also the note about implicit separators in the description of the
.Ic if
command.
.Pp
An 
.Ic =
can be used in place of 
.Ic from .
.Ed
.Ss Expressions
.Pp
.Nm
supports a most standard arithmatic operators: + - / * ^.  The carat
(^) is exponentiation.  It also supports the C logical operators ==, !=,
&&, || and unary !.  == and != are overloaded for the comparison of
quoted strings.  Parentheses are used for grouping.  
.Pp
Assignment is not allowed in an expression.
.Pp
.Nm
supports the following functions that take one argument:
.Ic log , exp , int , sin , cos , sqrt , rand .
The logarithms are base 10 and the trigonometric functions are in
radians.  If 
.Ic rand
is given an argument, it seeds the random number generator with that
value.  Called with no arguments, it returns a random number uniformly
distributed on [0,1).  The following two argument functions are supported:
.Ic atan2 , min , max .
.Ic atan2 
works just like
.Xr atan2 3 .
.Pp
Other than string comparison, no expressions can use strings.  One
string valued function exists: 
.Ic sprintf ( Ar format ,
.Oo
.Ar expr 
.Op Ar \&, expr
.Oc
).  It operates like
.Xr sprintf 3 ,
except returning the value.  It can be used anywhere a quoted string
is used.
.Ss Macros
.Nm
has a simple but powerful macro facility.  Macros are defined using
the 
.Ic define
command :
.Pp
.Ic define Ar name block
.Bd -filled -offset indent
Every occurrance of 
.Ar name
in the program text is replaced by the contents of 
.Ar block .
.Ar block
is defined by a series of statements in nested { }'s, or a series of
statements surrounded by the same letter.  An example of the latter is
.Bd -literal -offset indent-two
define foo  X coord x 1,3 X
.Ed
Each time 
.Li foo
appears in the text, it will be replaced by 
.Li coord x 1,3 .
Macros are literal, and can contain newlines.  If a macro does not
span multiple lines, it should end in a semicolon to avoid parsing
errors.
.Pp
Macros can take parameters, too.  If a macro call is followed by a
parenthesized, comma-separated list the values starting with $1 will
be replaced in the macro with the elements of the list.  A $ not
followed by a digit is left unchanged.  This parsing
is very rudimentary, no nesting or parentheses or escaping of commas
is allowed.  Also, there is no way to say argument 1 followed by a
digit (${1}0 in sh(1)).  A macro can have at most 32 arguments.
.Pp
The following will draw a line with slope 1.
.Bd -literal -offset indent-two
define foo { next at $1, $2 }
for i from 1 to 5 { foo(i,i) }
.Ed
Macros persist across graphs.  The file 
.Pa DEFINES
contains simple macros for plotting common characters.
.Pp
See the file
.Pa EXAMPLES
for more examples of macros.
.Ed
.Ss Number Lists
.Pp
A whitespace-separated list of numbers is treated specially.  The list
is taken to be points to be plotted using the default line style on
the default coordinate system.  If more than two numbers are given,
the extra numbers are taken to be additional y values to plot at the
first x value.  Number lists in DWB 
.Nm
can be comma-separated, and this 
.Nm
supports that as well.  More precisely, numbers in number lists can be
separated by either whitespace, commas, or both.
.Bd -literal -offset indent-two
1 2 3
4 5 6
.Ed
.sp
Will plot points using the default line style at (1,2), (1,3),(4,5)
and (4,6).  A simple way to plot a set of numbers in a file named 
.Pa ./data
is:
.Bd -literal -offset indent-two
.G1
copy "./data"
.G2
.Ed
.Sh FILES
.Pa DEFINES
.Sh SEE ALSO
.Xr atan2 3 ,
.Xr groff 1 ,
.Xr pic 1 ,
.Xr printf 3 ,
.Xr sh 1 ,
.Xr sprintf 3 ,
.Xr troff 1
.Sh AUTHOR
This implementation was done by
.An Ted Faber Ao faber@lunabase.org Ac .
.Nm
was designed and specified by 
.An Brian Kernighan
and 
.An Jon Bentley .
.Sh BUGS
.Pp
There are several small incompatibilities with K&R
.Nm grap .
They include the
.Ic sh
command not expanding variables and macros, and a more strict
adherence to parameter order in the internal commands.
